#!/usr/bin/perl

=head1 NAME

replicate - The SOS replication utility

=cut

=head1 SYNOPSIS

  replicate [options]

  General Options:

   --deamon      Specify that we should run constantly.
   --verbose     Show more explicitly what is going on.

  Help Options:

   --help        Show brief help instructions.
   --manual      Show the manual.

=cut

=head1 OVERVIEW

This utility is designed to synchronize the contents of each member of
a group of blob-servers.

blob-servers are defined in terms of groups, in the configuration file
C</etc/sos.conf> or C<~/.sos.conf>.  The most simple deployment consists
of a small number of servers all in the same group:

=for example begin

    $ cat ~/.sos.conf
    http://127.0.0.1:4000
    http://127.0.0.1:4001
    http://127.0.0.1:4002

=for example end

In this case there are three members in the group, so the uploaded objects
will be replicated twice, ensuring there are three copies in total.

In more realistic real-world deployments your definitions will contain
multiple groups - in that case replication will operate solely between
hosts defined in the same group.  For example you might define two groups
each of which has objects copied twice:

=for example begin

    $ cat ~/.sos.conf
    [1]
    -: http://127.0.0.1:4000
    -: http://127.0.0.1:4001
    [2]
    -: http://127.0.0.1:5000
    -: http://127.0.0.1:5001

=for example end

=cut

=head1 NOTES

It is not necessary for the blob-servers to communicate with each other,
providing the host running this replication script can communicate with
each of them.

=cut

=head1 LICENSE

This module is free software; you can redistribute it and/or modify it
under the terms of either:

a) the GNU General Public License as published by the Free Software
Foundation; either version 2, or (at your option) any later version,
or

b) the Perl "Artistic License".

=cut

=head1 AUTHOR

Steve Kemp <steve@steve.org.uk>

=cut


use strict;
use warnings;

use Encode qw(encode);
use Getopt::Long;
use JSON;
use LWP::UserAgent;
use Pod::Usage;


package SOS::Servers;



sub new
{
    my ($proto) = (@_);
    my $class = ref($proto) || $proto;
    my $self = {};

    # servers
    $self->{ 'servers' } = undef;

    bless( $self, $class );

    # Load our data.
    $self->_readFiles();
    return $self;
}


=begin doc

Read the known configuration files we understand.

Called when this object is instantiated.

=end doc

=cut

sub _readFiles
{
    my ($self) = (@_);

    $self->_readFile("/etc/sos.conf");
    $self->_readFile( $ENV{ 'HOME' } . "/.sos.conf" );
}


=begin doc

Read the known configuration files we understand.

=end doc

=cut

sub _readFile
{
    my ( $self, $file ) = (@_);

    return unless ( -e $file );

    my @data;

    open( my $handle, "<", $file ) or
      die "Failed to open $file - $!";
    while ( my $line = <$handle> )
    {
        chomp($line);
        next if ( $line =~ /^#/ );

        push( @data, $line );
    }
    close($handle);

    #
    #  OK this is either a literal list of servers, or
    # a list of ini-like sections.
    #
    my $is_ini = 0;

    foreach my $line (@data)
    {
        $is_ini = 1 if ( $line =~ /^\[(.*)\]$/ );
    }

    #
    #  Parse literal list, simple
    #
    if ( $is_ini == 0 )
    {
        foreach my $line (@data)
        {
            if ( $line =~ /^http/i )
            {
                $self->{ 'servers' }{ "default" }{ $line } = 1;
            }
        }
    }
    else
    {
        # Parse INI-file
        my $section = "";

        foreach my $line (@data)
        {
            # section
            if ( $line =~ /^\[(.*)\]$/ )
            {
                $section = $1;
            }
            if ( ( $line =~ /^-:(.*)$/ ) && $section )
            {
                # hostname
                my $uri = $1;
                $uri =~ s/^\s+//;
                $uri =~ s/\s+$//;

                $self->{ 'servers' }{ $section }{ $uri } = 1;
            }
        }
    }
}

=begin doc

Return the list of servers we've discovered via our configuration
file parsing.

=end doc

=cut

sub servers
{
    my ($self) = (@_);

    return ( %{ $self->{ 'servers' } } );
}




package main;


#
#  Default options: Don't be verbose and require two copies of each object.
#
my %CONFIG;
$CONFIG{ 'copies' }  = 2;
$CONFIG{ 'verbose' } = 0;


=begin doc

Given a list of servers make sure that each one has the same contents
as the rest in the list.

=end doc

=cut

sub replicate_group
{
    my (@nodes) = (@_);

    #
    # Get the list of objects on each server in the group.
    #
    my %objects = populateObjects(@nodes);

    #
    # OK so we have a list of servers, and the objects each contains.
    #
    # We want to make sure that every object is stored within every
    # other node in that set.
    #
    foreach my $server ( sort keys %objects )
    {
        #
        # So we've got a server we want to replicate
        # make sure it is alive.
        #
        if ( is_alive($server) == 0 )
        {
            print "blob-server offline: $server\n";
            next;
        }

        #
        # Look for all other servers in the group
        #
        foreach my $mirror ( sort keys %objects )
        {
            next if ( $mirror eq $server );

            $CONFIG{ 'verbose' } && print "Mirroring from $server -> $mirror\n";

            if ( is_alive($mirror) == 0 )
            {
                print "Replication target offline: $mirror\n";
                next;
            }

            #
            #  The objects we wish to replicate.
            #
            my @ids = keys %{ $objects{ $server } };

            #
            #  SHow them
            #
            foreach my $id (@ids)
            {
                $CONFIG{ 'verbose' } && print "\t$id";

                if ( $objects{ $mirror }{ $id } )
                {
                    $CONFIG{ 'verbose' } && print " - present\n";
                }
                else
                {
                    $CONFIG{ 'verbose' } && print " - ";
                    replicate_object( $id, $server, $mirror );
                }
            }
        }
    }

}




#
# Replicate the given file
#
sub replicate_object
{
    my ( $id, $src, $dst ) = (@_);

    #  OK we've now got to download the content
    #
    my $lwp = LWP::UserAgent->new;
    my $uri = $src . "/blob/$id";
    my $res = $lwp->get($uri);

    if ( $res->is_success() )
    {
        #
        #  We have the data now, ensure it is UTF-8.
        #
        my $data = $res->decoded_content();
        my $body = encode( 'UTF-8', $data );

        #
        # Get the headers
        #
        my $headers = $res->headers();

        #
        #  Prepare to upload to new location
        #
        my $req = HTTP::Request->new( 'POST', $dst . "/blob/$id" );

        #
        #  Add the content, and any headers.
        #
        $req->content($body);

        foreach my $header ( keys %{ $headers } )
        {
            $req->header( $header, $headers->{ $header } )
              if ( $header =~ /^x-/i );
        }

        #
        # Make the request
        #
        my $res = $lwp->request($req);
        if ( $res->is_success() )
        {
            $CONFIG{ 'verbose' } && print "replicated.\n";
        }
        else
        {
            print "FAILED to replicate" . $res->status_line() . "\n";
        }
    }
    else
    {
        die "Failed to download $uri to replicate to $dst";
    }
}


#
# Populate a hash of each known object on each server.
#
sub populateObjects
{
    my (@nodes) = (@_);

    my %ret;

    foreach my $server ( sort(@nodes) )
    {
        #
        #  Ensure this server has an empty hash against it.
        #
        my %x;
        $ret{ $server } = \%x;

        $CONFIG{ 'verbose' } &&
          print "Downloading contents of blob-server $server\n";

        next if ( is_alive($server) == 0 );

        my $lwp = LWP::UserAgent->new;

        my $uri = $server . "/blobs";
        my $res = $lwp->get($uri);

        if ( $res->is_success() )
        {
            my $ids = decode_json( $res->decoded_content() );

            foreach my $id (@$ids)
            {
                $ret{ $server }{ $id } = 1;
            }
        }
        else
        {
            die "Failed to download contents from server $server";
        }
    }
    $CONFIG{ 'verbose' } &&
      print "\n";

    return (%ret);

}


=begin doc

Is the given server alive?  (Caches result).

=end doc

=cut

my %alive;

sub is_alive
{
    my ($server) = (@_);

    return ( $alive{ $server } ) if ( defined $alive{ $server } );


    my $ua = LWP::UserAgent->new;
    $ua->timeout(10);
    $ua->env_proxy;

    my $response = $ua->get( $server . '/alive' );
    my $code     = $response->code();
    my $body     = $response->decoded_content();

    if ( $body && $body =~ /^alive$/i )
    {
        $alive{ $server } = 1;
    }
    else
    {
        $alive{ $server } = 0;
    }

    return ( $alive{ $server } );
}



#
#  Parse options from the command-line.
#
exit
  if (
    !GetOptions(

        # Help options
        "help",     \$CONFIG{ 'help' },
        "manual",   \$CONFIG{ 'manual' },
        "verbose",  \$CONFIG{ 'verbose' },
        "daemon=i", \$CONFIG{ 'daemon' },
    ) );


pod2usage(1) if ( $CONFIG{ 'help' } );
pod2usage( -verbose => 2 ) if ( $CONFIG{ 'manual' } );


#
#  If we've been given a --daemon flag then we'll repeat
# the sync, otherwise we'll just run it once.
#
do
{

    #
    #  Parse the configuration file(s) so we get a list of servers.
    #
    my $obj = SOS::Servers->new();
    my %srv = $obj->servers();

    #
    # If we have no servers then we must abort.
    #
    if ( !scalar( keys %srv ) )
    {
        print <<EOF;
No servers were found in the configuration file(s).  Aborting.
EOF
        exit(1);
    }


    #
    #  For each group we need to replicate the contents.
    #
    foreach my $group ( sort keys %srv )
    {
        $CONFIG{ 'verbose' } && print "Replicating group: $group\n";

        my @nodes = sort keys( %{ $srv{ $group } } );

        replicate_group(@nodes);
    }

    # sleep?
    sleep( $CONFIG{ 'daemon' } ) if ( $CONFIG{ 'daemon' } );

} while ( $CONFIG{ 'daemon' } );


#
#  All done.
#
exit(0);
